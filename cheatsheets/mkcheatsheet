#!ruby

require 'caracal'
require 'json'

COLOR_TABLE_BORDER = 'bfc0bf'
COLOR_TABLE_STRIPE = 'efefef'
COLOR_HEADER_BK    = 'c0bfc0'
COLOR_NAME_COL     = 'e2e4e3'

ACTIONS_HEADER = %w[Action Who Effect]
ACTIONS_COLUMNS_CONFIG = [
  { align: :left, background: COLOR_NAME_COL, bold: true }
]

SPELLS_HEADER = %w[Spell Who Effect]
SPELLS_COLUMNS_CONFIG = [
  { align: :left, background: COLOR_NAME_COL, bold: true }
]

STATS_HEADER = %w[Name Move F S D A C I Notes]

STATS_COLUMNS_CONFIG = [
  { align: :left, background: COLOR_NAME_COL, bold: true },
  { align: :center, width: 705 },
  { align: :center, width: 634 },
  { align: :center, width: 245 },
  { align: :center, width: 504 },
  { align: :center, width: 245 },
  { align: :center, width: 245 },
  { align: :center, width: 245 }
]

STATS_TRACKER_COLUMNS_CONFIG = [
  { align: :left, background: COLOR_NAME_COL, bold: true },
  { align: :center },
  { align: :center },
  { align: :center },
  { align: :center }
]

#========================================================================
class Scenario
  attr_accessor :docx_output_filename, :title

  @input_json
  @actions
  @profiles
  @specials
  @spells

  #------------------------------------------------------------------------
  def initialize(filename)
    @docx_output_filename = filename.sub('.json', '.docx')
    @title = filename.sub(%r{^.*/}, "").sub(/.json/, '').sub(/^\d+\s*/, "")

    @input_json = JSON.load_file!(filename)

    @actions  = JSON.load_file!('./data/actions.json')
    @profiles = JSON.load_file!('./data/profiles.json')
    @specials = JSON.load_file!('./data/specials.json')
    @spells   = JSON.load_file!('./data/spells.json')
  end

  #------------------------------------------------------------------------
  def actions_for(name)
    attribute_override(name, 'actions') || @profiles[name]['actions'] || []
  end

  #------------------------------------------------------------------------
  def apply_table_formatting(config, table_name, side='both')
    config = config.clone

    column_sizes_for(table_name, side).each do |col_spec|
      config[col_spec['column']]['width'] = 20.0 * 72.0 * col_spec['width']
    end

    config
  end

  #------------------------------------------------------------------------
  def attribute_override(name, attribute)
    if @input_json['overrides'] &&
       @input_json['overrides'][name] &&
       @input_json['overrides'][name][attribute]
      return @input_json['overrides'][name][attribute]
    end

    return nil
  end

  #------------------------------------------------------------------------
  def column_sizes_for(table, side)
    (@input_json["formatting"] &&
     @input_json["formatting"]["tables"] &&
     @input_json["formatting"]["tables"][table] &&
     @input_json["formatting"]["tables"][table][side]) || []
  end

  #------------------------------------------------------------------------
  def effect_for_action(action_name)
    @actions[action_name]['effect']
  end

  #------------------------------------------------------------------------
  def effect_for_special(special_name)
    # Most common case is a straightforward lookup
    if @specials[special_name] && @specials[special_name]['effect']
      return @specials[special_name]['effect']
    end

    # When that fails, this might be a templatized special
    template_key = @specials.keys.find { |k| Regexp.new(Regexp.escape(k).sub('%s', '(.*)')).match(special_name) }

    abort "no effect found for special [#{special_name}]!" unless template_key && $1

    @specials[template_key]['effect'].sub('%s', $1)
  end

  #------------------------------------------------------------------------
  def effect_for_spell(spell_name)
    @spells[spell_name]['effect']
  end

  #------------------------------------------------------------------------
  def magic_for(name)
    attribute_override(name, 'magic') || @profiles[name]['magic'] || []
  end

  #------------------------------------------------------------------------
  # side - 'good' or 'evil'
  #------------------------------------------------------------------------#
  def objectives(side)
    @input_json['objectives'][side]
  end

  #------------------------------------------------------------------------
  # side - 'good' or 'evil'
  #------------------------------------------------------------------------#
  def order_of_battle(side)
    @input_json[side]
  end

  #------------------------------------------------------------------------
  def page_break_before(section_name)
    @input_json["formatting"] &&
      @input_json["formatting"]["pageBreakBefore"] &&
      @input_json["formatting"]["pageBreakBefore"].include?(section_name)
  end

  #------------------------------------------------------------------------
  def special_rules
    @input_json['specialRules']
  end

  #------------------------------------------------------------------------
  def specials_for(name)
    attribute_override(name, 'specials') || @profiles[name]['specials'] || []
  end

  #------------------------------------------------------------------------
  def statline_for(name)
    abort "no profile for #{name}!" unless @profiles[name]
    attribute_override(name, 'statline') || @profiles[name]['statline']
  end
end

#========================================================================
def actions_table(doc, scenario)
  all_names = scenario.order_of_battle('good') + scenario.order_of_battle('evil')
  actions_hash = all_names.reduce({}) do |result, role|
    name = role['name']
    scenario.actions_for(name).each do |a|
      result[a] = [] unless result[a]
      result[a].push(name)
      result[a].sort!
    end

    result
  end

  unless actions_hash.empty?
    action_data = actions_hash.keys.sort.map { |name| [ name ] }

    actions_hash.each do |k,v|
      entry = action_data.find { |array| array[0] == k }
      entry.push(actions_hash[k].join("\n"))
      entry.push(scenario.effect_for_action(k))
    end

    config = ACTIONS_COLUMNS_CONFIG
    config = dynamic_col_w(action_data, config)
    config = dynamic_col_w(action_data, config, 1)
    config = scenario.apply_table_formatting(config, 'actions')

    if scenario.page_break_before("actions")
      doc.page
    else
      doc.p
    end
    doc.p 'Heroic Actions', style: 'Section Heading'
    static_stats_table(doc, [ ACTIONS_HEADER ] + action_data, config)
  end
end

#========================================================================
def boxes(n)
  return '' unless n
  ('O' * n.to_i).gsub('OOO', 'OOO ').reverse
end

#========================================================================
def cell_size(str)
  x = str.split(/\n/).max_by { |s| s.size }
  x.size
end

#========================================================================
def create_dynamic_stats(scenario)
  all_roles = scenario.order_of_battle('good') + scenario.order_of_battle('evil')
  all_roles.reduce([]) do |result, role|
    name = role['name']
    stats = scenario.statline_for(name)
    if stats[6] == 1 && stats[9] == '-' && stats[10] == '-' && stats[11] == '-'
      result
    else
      num_copies = role['amt'] || 1
      (1..num_copies).each do |n|
        nth = num_copies > 1 ? " ##{n}" : ''
        result << [ "#{name}#{nth}", boxes(stats[6]), boxes(stats[9]), boxes(stats[10]), boxes(stats[11]) ]
      end
      result
    end
  end
end

#========================================================================
def create_static_stats(scenario, side)
  profile_list = scenario.order_of_battle(side)
  [STATS_HEADER] + profile_list.map do |p|
    name = p['name']
    stats = scenario.statline_for(name)
    specials = scenario.specials_for(name)

    array = [name] +
            [stats[0]] +
            ["#{stats[1]}/#{stats[2]}"] +
            stats[3..5] +
            stats[7..8]
    array + (specials ? [ specials.join(', ') ] : [ '' ])
  end
end

#========================================================================
def dynamic_col_w(data_array, config_template, col=0)
  copy = config_template.clone

  longest = data_array.max_by { |row| cell_size(row[col]) }

  copy[col] = {} unless copy[col]
  copy[col]['width'] = (cell_size(longest[col]) * 20 * 72 * 0.09).to_i

  copy
end

#========================================================================
def dynamic_stats_table(doc, table_data)
  static_stats_table(doc,
              table_data.unshift(%w(Name Wounds Might Will Fate)),
              dynamic_col_w(table_data, STATS_TRACKER_COLUMNS_CONFIG))
end

#========================================================================
def specials_for(doc, scenario, side)
  specials = scenario.order_of_battle(side)
               .map { |role| role['name'] }
               .flat_map { |name| scenario.specials_for(name) }
               .uniq
               .sort

  effect = nil

  specials.each do |s|
    effect = scenario.effect_for_special(s)

    doc.p do
      text s, bold: true
      text ': '
      text effect
    end
  end
end

#========================================================================
def spells_table(doc, scenario, title)
  side = title.downcase
  spell_hash = scenario.order_of_battle(side).reduce({}) do |result, role|
    magic_list = scenario.magic_for(role['name'])
    magic_list.each do |spell|
      spell_name = spell['spell']
      result[spell_name] = [] unless result[spell_name]
      result[spell_name].push(spell.clone.merge!({ 'name' => role['name'] }))
    end
    result
  end

  unless spell_hash.empty?
    spell_data = spell_hash.keys.sort.map { |name| [ name ] }

    spell_hash.each do |k,v|
      if v.size == 1
        range = v[0]['range']
        spell_entry = spell_data.find { |array| array[0] == k }
        spell_entry.push("#{v[0]['name']} #{range}#{range.is_a?(Integer) ? '"' : ''} #{v[0]['dr']}+")
        spell_entry.push(scenario.effect_for_spell(k))
      else
        puts "OOPS #{k.inspect} => #{v.inspect}" # TODO
      end
    end

    config = SPELLS_COLUMNS_CONFIG
    config = dynamic_col_w(spell_data, config)
    config = dynamic_col_w(spell_data, config, 1)
    config = scenario.apply_table_formatting(config, 'spells', side)

    doc.p
    doc.p "#{title} Spells", style: 'Section Heading'
    static_stats_table(doc, [ SPELLS_HEADER ] + spell_data, config)
  end
end

#========================================================================
def static_stats_table(doc, data_array, config=[])
  doc.table data_array do
    align :center
    border_color COLOR_TABLE_BORDER
    border_size 4
    width 10800

    data_array.each_index do |i|
      next if i < 2 || (i & 1 == 1)
      cell_style rows[i], background: COLOR_TABLE_STRIPE
    end

    cell_style rows[0], background: COLOR_HEADER_BK, style: 'Table Header', align: :center

    config.each_index do |i|
      cell_style cols[i], config[i]
    end

    cell_style rows[0][0], background: COLOR_HEADER_BK # cols[0] overwrote this, so reset it
  end
end

#========================================================================
# MAIN PROGRAM
#------------------------------------------------------------------------

abort 'usage: mkcheatsheet </path/to/scenario.json>' unless ARGV.length == 1

scenario = Scenario.new(ARGV[0])

docx = Caracal::Document.new(scenario.docx_output_filename)

docx.page_margins do
  bottom 720
  left 720
  right 720
  top 720
end

docx.style do
  id 'Title'
  name 'title'
  font 'Helvetica Neue'
  size 60
  align :center
  bold true
end

docx.style do
  id 'Normal'
  name 'normal'
  font 'Helvetica Neue'
  size 20
  line 240
end

docx.style do
  id 'Section Heading'
  name 'section_heading'
  font 'Helvetica Neue'
  size 20
  align :center
  bold true
end

docx.style do
  id 'Table Header'
  name 'table_header'
  font 'Helvetica Neue'
  size 20
  bold true
end

docx.p scenario.title, style: 'Title'

good_stats = create_static_stats(scenario, 'good')
evil_stats = create_static_stats(scenario, 'evil')

docx.p
docx.p 'Good Character Stats', style: 'Section Heading'
static_stats_table(docx, good_stats, dynamic_col_w(good_stats, STATS_COLUMNS_CONFIG))
specials_for(docx, scenario, 'good')

docx.p
docx.p 'Evil Character Stats', style: 'Section Heading'
config = STATS_COLUMNS_CONFIG
config = dynamic_col_w(evil_stats, config)
config = scenario.apply_table_formatting(config, "stats", "evil")
static_stats_table(docx, evil_stats, config)
specials_for(docx, scenario, 'evil')

docx.p
docx.page if scenario.page_break_before('Expended Stats')
docx.p 'Expended Stats', style: 'Section Heading'
dynamic_stats_table(docx, create_dynamic_stats(scenario))

actions_table(docx, scenario)
spells_table(docx, scenario, 'Good')
spells_table(docx, scenario, 'Evil')

docx.p
docx.p 'Objectives', style: 'Section Heading'
%w(good evil).each do |side|
  docx.p do
    text side.capitalize, bold: true
    text ': '
    text scenario.objectives(side)
  end
end

docx.p
docx.p 'Scenario Special Rules', style: 'Section Heading'
scenario.special_rules().each do |k,v|
  docx.p do
    text k, bold: true
    text ': '
    text v
  end
end

docx.save
